<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Application 6 Demo – Real-Time ICU Nurse Call System</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        max-width: 850px;
        margin: 40px auto;
        padding: 0 20px;
      }
      h1, h2 {
        color: #2c2c2c;
      }
      iframe {
        width: 100%;
        height: 420px;
        border: none;
        margin-top: 10px;
      }
    </style>
  </head>

  <body>

    <h1>Application 6 Demo – Real-Time ICU Nurse Call Simulation</h1>

    <p>
      This project simulates a simplified ICU nurse-call and emergency alert system using real-time
      scheduling concepts. The goal is to demonstrate how interrupts, semaphores, shared data, and periodic
      tasks work together to guarantee predictable timing — something critical in hospital environments.
    </p>

    <h2>Video Demo</h2>

    <iframe 
      src="https://www.youtube.com/embed/Oi0fLByTgjw"
      title="YouTube video player"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen>
    </iframe>

    <h2>Project Overview</h2>
    <p>
      In a real ICU, nurses rely on call buttons and automated systems that must respond immediately to
      emergencies. This project recreates that idea using a Raspberry Pi programmed with real-time tasks.
      When a nurse button is pressed, an interrupt fires, signaling the rest of the system. Multiple tasks
      then react based on strict timing rules, so the alert is handled without delay.
    </p>

    <h2>How the System Works</h2>

    <p>
      The system includes an emergency button connected to GPIO 18. When the button is pressed on the falling
      edge, an Interrupt Service Routine (ISR) runs instantly. Because ISRs must stay short and predictable,
      they do not handle the emergency directly. Instead, it “signals” the rest of the system by giving a binary
      semaphore called <strong>sem_emergency</strong>.
    </p>

    <p>
      The <strong>EmergencyTask</strong> waits on this semaphore. As soon as the ISR releases it, the task wakes up
      and toggles a shared variable called <strong>system_emergency</strong>. This variable is used by other tasks to know
      whether the system is currently in an emergency state.
    </p>

    <p>
      The <strong>AlarmEvalTask</strong> runs every 50 ms. This task reads two things:  
      1) simulated patient vital signs from a queue and  
      2) the <strong>system_emergency</strong> flag.  
      Using these, it decides how to control the LEDs. If vitals cross a danger threshold or if an emergency is
      active, the LED patterns change to reflect the alert level. Because this is a hard real-time task, it must run
      on schedule every 50 ms with no missed deadlines.
    </p>

    <p>
      A <strong>StatusLoggerTask</strong> runs every 1000 ms and logs the system state. This is a soft real-time task,
      meaning minor timing delays are acceptable. The logger helps visualize system behavior over time.
    </p>

    <p>
      Together, these tasks form a small but realistic example of how hospitals rely on predictable timing and
      interrupt-driven alerts to keep patients safe. The main idea is that emergencies do not wait, and a real-time
      system must guarantee it always responds on time.
    </p>

    <h2>About This Website</h2>
    <p>
      For this assignment, the project had to be published using GitHub Pages with an embedded video.
      This site demonstrates a basic but complete workflow:  
      creating a repository, enabling Pages, writing an HTML project description, and embedding a YouTube demo.
    </p>

    <p>
      Later, this could be expanded into a full project page with code, diagrams, source files,
      documentation, and downloadable builds.
    </p>

  </body>
</html>
